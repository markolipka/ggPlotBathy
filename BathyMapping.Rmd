---
title: "Bathymetry Mapping with R"
author: "Marko Lipka"
output: 
  html_document: 
    fig_height: 10
    fig_width: 12
    theme: spacelab
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)
```

### Get bathymetry data

The *marmap* package provides world wide high resolution bathymetry data.

```{r getBathymetryData}
library("marmap")
library("ggplot2")
get.bathymetry <- function(lon1=4, lon2=30, lat1=53, lat2=67, bathy.breaks = 8){
  bathymetry <- getNOAA.bathy(lon1=lon1, lon2=lon2, lat1=lat1, lat2=lat2, resolution=1, keep=TRUE) # keep = TRUE saves downloaded data as csv-File
  fortyfied.bathy <- fortify(bathymetry) # make a df out of bathy so ggplot can fully use the data
  fortyfied.bathy <- subset(fortyfied.bathy, z <= 0) # limit to values below sea surface
  fortyfied.bathy$z <- -fortyfied.bathy$z # make depths positive values
  names(fortyfied.bathy) <- c("Longitude", "Latitude", "Depth_m")
  fortyfied.bathy$Depthsteps_m <- cut(fortyfied.bathy$Depth_m, breaks = bathy.breaks, dig.lab = 4) # generate depth intervals for contour plot
  ## 'cut()' returns intervals in unpleasant format. Thus, cumbersome renaming for nice legend:
  fortyfied.bathy <- subset(fortyfied.bathy, !is.na(fortyfied.bathy$Depthsteps_m))
    levels(fortyfied.bathy$Depthsteps_m) <- sub(",", " - ", levels(fortyfied.bathy$Depthsteps_m))
    levels(fortyfied.bathy$Depthsteps_m) <- sub("\\(", "", levels(fortyfied.bathy$Depthsteps_m))
    levels(fortyfied.bathy$Depthsteps_m) <- sub("\\]", "", levels(fortyfied.bathy$Depthsteps_m))
    levels(fortyfied.bathy$Depthsteps_m) <- sub("(.*) - Inf", ">\\1", levels(fortyfied.bathy$Depthsteps_m))
  return(fortyfied.bathy)
}
```

```{r}
baltic.bathy   <- get.bathymetry(lon1 = 4, lon2 = 30, 
                                 lat1 = 53, lat2 = 67,
                                 bathy.breaks = c(seq(0, 50, length.out = 6),
                                                  seq(100, 300, length.out = 3),
                                                  +Inf))

ggplot(baltic.bathy) + 
    geom_tile(aes(x=Longitude, y=Latitude, fill=Depthsteps_m)) +
    scale_fill_brewer(palette = "Blues", name = "Water depth [m]") 
```


### Load world coastlines

The *mapdata* package allows to download world coastline polygon data. Unfortunately these are missing some 'small' islands (like Hiddensee).
Haven't found a workaround for that yet...

```{r getCoastlines}
library("mapdata")
baltic.coastlines <- map_data('worldHires', xlim = c(4, 29), ylim = c(50, 66))

ggplot(baltic.coastlines) +
  geom_polygon(aes(x=long, y=lat, group=group), colour = "white")
```


### Plot some maps

```{r plotFunction}
 land.colour   <- NA
 border.colour <- "red"

plot.map <- function(bathy = baltic.bathy, basemap = baltic.coastlines, xmin = 5, xmax = 30, ymin = 53.5, ymax = 66){
    ggplot() +
    coord_quickmap(#projection= "azequalarea",
      xlim=c(xmin, xmax), ylim=c(ymin, ymax)) +
    geom_tile(data = bathy, aes(x=Longitude, y=Latitude, fill=Depthsteps_m)) +
    scale_fill_brewer(palette = "Blues", name = "Water depth [m]") +
    geom_polygon(data=basemap, aes(x=long, y=lat, group=group), fill=land.colour, colour = border.colour, lwd=.5) +
    theme_minimal()

# plot.map <- function(bathy = baltic.bathy, basemap = baltic.coastlines, xmin = 5, xmax = 30, ymin = 53.5, ymax = 66){
#     ggmap() +#satmap) +
#     coord_quickmap(#projection= "azequalarea",
#       xlim=c(xmin, xmax), ylim=c(ymin, ymax)) +
#     geom_tile(data = bathy, aes(x=Longitude, y=Latitude, fill=Depthsteps_m)) +
#     scale_fill_brewer(palette = "Blues", name = "Water depth [m]") +
#         geom_polygon(data=basemap, aes(x=long, y=lat, group=group), fill=land.colour, colour = border.colour, lwd=.5) +
#     theme_minimal()
}
```

#### The whole Baltic Sea:

```{r Map_BalticSea}
plot.map()
```

#### The southern part only:

... with the bathymetry depth range of the whole Baltic Sea ...

```{r Map_SouthernBalticSea}
plot.map(xmin = 10, xmax = 20, ymin = 54, ymax = 58)
```

... or adapted to plot region.

```{r Map_SouthernBalticSea_ownDepRange}
southern.baltic.bathy   <- get.bathymetry(lon1 = 10, lon2 = 20, 
                                 lat1 = 54, lat2 = 58,
                                 bathy.breaks = c(seq(0, 50, length.out = 6),
                                                  +Inf))
plot.map(bathy = southern.baltic.bathy, xmin = 10, xmax = 20, ymin = 54, ymax = 58)
```

#### Should also work for any other region in the world

```{r Map_randomRegion}
long <- 110
lat <- 5

region.bathy <- get.bathymetry(lon1 = long, lon2 = long + 40, lat1 = lat, lat2 = lat + 15,
                               bathy.breaks = c(0, 1000, 2000, 3000, 4000, 5000, 7000, 9000, Inf))
region.coastlines <- map_data('worldHires', xlim = c(long, long +40), ylim = c(lat, lat + 15))
plot.map(bathy = region.bathy, basemap = region.coastlines, xmin = long, xmax = long +40, ymin = lat, ymax = lat + 15)
```

Viola! Have fun ...

## Known issues / \#TODO:

* map_data even with *map = 'worldHires'* does not include all islands:
  + is there another source for high resolution coastlines of the world?
  + is the coastline necessary ?
* map generation should be transferred into a function, so that coordinates only have to be set once. The margins for bathymetry and coastline 
basemap must be slightly larger than the actual plot margins. Otherwise the map is not completely filled out with bathy-data (see last 2 plots).
* would be nice to have some options for the colour scale of bathymetry
    + continuous vs. discrete
    + colour gradient selection
    + more convenient labeling / interval selection